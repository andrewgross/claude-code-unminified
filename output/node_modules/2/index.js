var F = require(1);
function I() {}
var Y = {};
var W = ["REJECTED"];
var J = ["FULFILLED"];
var X = ["PENDING"];
module.exports = V;
function V(P) {
  if (typeof P !== "function") {
    throw new TypeError("resolver must be a function");
  }
  this.state = X;
  this.queue = [];
  this.outcome = undefined;
  if (P !== I) {
    z(this, P);
  }
}
V.prototype.catch = function (P) {
  return this.then(null, P);
};
V.prototype.then = function (P, j) {
  if (typeof P !== "function" && this.state === J || typeof j !== "function" && this.state === W) {
    return this;
  }
  var f = new this.constructor(I);
  if (this.state !== X) {
    var k = this.state === J ? P : j;
    K(f, k, this.outcome);
  } else {
    this.queue.push(new C(f, P, j));
  }
  return f;
};
function C(P, j, f) {
  this.promise = P;
  if (typeof j === "function") {
    this.onFulfilled = j;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof f === "function") {
    this.onRejected = f;
    this.callRejected = this.otherCallRejected;
  }
}
C.prototype.callFulfilled = function (P) {
  Y.resolve(this.promise, P);
};
C.prototype.otherCallFulfilled = function (P) {
  K(this.promise, this.onFulfilled, P);
};
C.prototype.callRejected = function (P) {
  Y.reject(this.promise, P);
};
C.prototype.otherCallRejected = function (P) {
  K(this.promise, this.onRejected, P);
};
function K(P, j, f) {
  F(function () {
    var k;
    try {
      k = j(f);
    } catch (c) {
      return Y.reject(P, c);
    }
    if (k === P) {
      Y.reject(P, new TypeError("Cannot resolve promise with itself"));
    } else {
      Y.resolve(P, k);
    }
  });
}
Y.resolve = function (P, j) {
  var f = $(H, j);
  if (f.status === "error") {
    return Y.reject(P, f.value);
  }
  var k = f.value;
  if (k) {
    z(P, k);
  } else {
    P.state = J;
    P.outcome = j;
    var c = -1;
    var u = P.queue.length;
    while (++c < u) {
      P.queue[c].callFulfilled(j);
    }
  }
  return P;
};
Y.reject = function (P, j) {
  P.state = W;
  P.outcome = j;
  var f = -1;
  var k = P.queue.length;
  while (++f < k) {
    P.queue[f].callRejected(j);
  }
  return P;
};
function H(P) {
  var j = P && P.then;
  if (P && (typeof P === "object" || typeof P === "function") && typeof j === "function") {
    return function f() {
      j.apply(P, arguments);
    };
  }
}
function z(P, j) {
  var f = false;
  function k(l) {
    if (f) {
      return;
    }
    f = true;
    Y.reject(P, l);
  }
  function c(l) {
    if (f) {
      return;
    }
    f = true;
    Y.resolve(P, l);
  }
  function u() {
    j(c, k);
  }
  var a = $(u);
  if (a.status === "error") {
    k(a.value);
  }
}
function $(P, j) {
  var f = {};
  try {
    f.value = P(j);
    f.status = "success";
  } catch (k) {
    f.status = "error";
    f.value = k;
  }
  return f;
}
V.resolve = L;
function L(P) {
  if (P instanceof this) {
    return P;
  }
  return Y.resolve(new this(I), P);
}
V.reject = N;
function N(P) {
  var j = new this(I);
  return Y.reject(j, P);
}
V.all = R;
function R(P) {
  var j = this;
  if (Object.prototype.toString.call(P) !== "[object Array]") {
    return this.reject(new TypeError("must be an array"));
  }
  var f = P.length;
  var k = false;
  if (!f) {
    return this.resolve([]);
  }
  var c = new Array(f);
  var u = 0;
  var a = -1;
  var l = new this(I);
  while (++a < f) {
    y(P[a], a);
  }
  return l;
  function y(t, E1) {
    j.resolve(t).then(C1, function (_1) {
      if (!k) {
        k = true;
        Y.reject(l, _1);
      }
    });
    function C1(_1) {
      c[E1] = _1;
      if (++u === f && !k) {
        k = true;
        Y.resolve(l, c);
      }
    }
  }
}
V.race = O;
function O(P) {
  var j = this;
  if (Object.prototype.toString.call(P) !== "[object Array]") {
    return this.reject(new TypeError("must be an array"));
  }
  var f = P.length;
  var k = false;
  if (!f) {
    return this.resolve([]);
  }
  var c = -1;
  var u = new this(I);
  while (++c < f) {
    a(P[c]);
  }
  return u;
  function a(l) {
    j.resolve(l).then(function (y) {
      if (!k) {
        k = true;
        Y.resolve(u, y);
      }
    }, function (y) {
      if (!k) {
        k = true;
        Y.reject(u, y);
      }
    });
  }
}