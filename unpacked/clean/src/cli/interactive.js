/**
 * Interactive Application Component
 * 
 * Main React-based interactive terminal UI for Claude Code CLI.
 * Handles user input, conversation flow, tool execution, and real-time updates.
 * 
 * Key chunks analyzed:
 * - chunk_0640.js:2-300+ (_A1 function - main interactive component)
 * - chunk_0640.js React hooks and state management patterns
 * - chunk_0640.js conversation and tool execution flow
 */

import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { render } from 'ink';
import { configManager } from '../config/manager.js';
import { mcpServerManager } from '../mcp/manager.js';
import { hookManager } from '../hooks/manager.js';
import { agentManager } from '../agents/manager.js';

/**
 * Interactive Application Component
 * 
 * Extracted from chunk_0640.js:2-300+ (_A1 function):
 * - Complex React state management for conversation flow
 * - Real-time tool execution and streaming responses
 * - MCP client integration and dynamic configuration
 * - Hook system integration for lifecycle events
 * - Advanced error handling and user feedback
 * - Session management and persistence
 */
export function InteractiveApp({
    commands,
    debug = false,
    initialPrompt,
    initialTools = [],
    initialMessages = [],
    initialTodos = [],
    initialCheckpoints = {},
    mcpClients = [],
    dynamicMcpConfig = {},
    autoConnectIdeFlag = false,
    strictMcpConfig = false,
    appendSystemPrompt
}) {
    // Core application state (from chunk_0640.js:16-44)
    const [appState, setAppState] = useState(() => ({
        verbose: configManager.get('verbose', false),
        mainLoopModel: getMainLoopModel(),
        todoFeatureEnabled: configManager.get('todoFeatureEnabled', false),
        toolPermissionContext: createInitialPermissionContext(),
        maxRateLimitFallbackActive: false,
        mcp: {
            clients: [],
            tools: [],
            commands: [],
            resources: {}
        },
        plugins: {
            enabled: [],
            disabled: [],
            commands: [],
            agents: []
        },
        statusLineText: undefined,
        checkpointing: {
            status: 'uninitialized',
            saving: false,
            checkpoints: initialCheckpoints,
            shadowRepoPath: undefined,
            autocheckpointEnabled: false\n        }\n    }));\n    \n    // UI and interaction state\n    const [currentMode, setCurrentMode] = useState('prompt');\n    const [turnCount, setTurnCount] = useState(1);\n    const [isStreaming, setIsStreaming] = useState(false);\n    const [notification, setNotification] = useState(null);\n    \n    // MCP and tool state\n    const [mcpConfigOverride, setMcpConfigOverride] = useState(dynamicMcpConfig);\n    const [mergedMcpClients, setMergedMcpClients] = useState([]);\n    const [availableTools, setAvailableTools] = useState(initialTools);\n    const [mergedCommands, setMergedCommands] = useState([]);\n    const [selectedIDE, setSelectedIDE] = useState(undefined);\n    \n    // Conversation and execution state (from chunk_0640.js:45-52)\n    const [streamMode, setStreamMode] = useState('responding');\n    const [streamingChunks, setStreamingChunks] = useState([]);\n    const [abortController, setAbortController] = useState(null);\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [userInputOnProcessing, setUserInputOnProcessing] = useState(undefined);\n    const [toolJSX, setToolJSX] = useState(null);\n    const [executionQueue, setExecutionQueue] = useState([]);\n    const [messages, setMessages] = useState(initialMessages);\n    const [messageHistory, setMessageHistory] = useState([]);\n    const [showSpinner, setShowSpinner] = useState(false);\n    const [currentInput, setCurrentInput] = useState('');\n    const [inputMode, setInputMode] = useState('prompt');\n    \n    // Advanced state management\n    const [queuedCommands, setQueuedCommands] = useState([]);\n    const [responseMetrics, setResponseMetrics] = useState({});\n    const [responseLength, setResponseLength] = useState(0);\n    const [tokenCount, setTokenCount] = useState(0);\n    const [spinnerMessage, setSpinnerMessage] = useState(null);\n    const [inProgressToolUseIDs, setInProgressToolUseIDs] = useState(new Set());\n    const [editMode, setEditMode] = useState('INSERT');\n    const [isValidating, setIsValidating] = useState(false);\n    const [ideToInstallExtension, setIDEToInstallExtension] = useState(null);\n    const [ideInstallationStatus, setIDEInstallationStatus] = useState(null);\n    const [showIdeOnboarding, setShowIdeOnboarding] = useState(false);\n    \n    // Refs for persistent data\n    const processingRef = useRef(false);\n    const queuedCommandsRef = useRef([]);\n    \n    // Initialize MCP clients and tools (from chunk_0640.js:36-44)\n    const mergedMcpClientsComputed = useMemo(() => {\n        return mergeMcpClients(mcpClients, appState.mcp.clients);\n    }, [mcpClients, appState.mcp.clients]);\n    \n    const availableToolsComputed = useMemo(() => {\n        return [...createToolSystem(appState.toolPermissionContext, appState.todoFeatureEnabled), ...availableTools];\n    }, [appState.toolPermissionContext, appState.todoFeatureEnabled, availableTools]);\n    \n    // Initialize system components\n    useEffect(() => {\n        initializeInteractiveSystem();\n        initializeIDEIntegration();\n        \n        return () => {\n            cleanup();\n        };\n    }, []);\n    \n    // Handle MCP client management (from chunk_0640.js:45-46)\n    useEffect(() => {\n        manageMcpClients(appState.mcp.clients, setSelectedIDE);\n        integrateWithMcpClients(appState.mcp.clients, setSelectedIDE);\n    }, [appState.mcp.clients]);\n    \n    // Clear execution state helper (from chunk_0640.js:50-52)\n    const clearExecutionState = useCallback(() => {\n        setIsProcessing(false);\n        setUserInputOnProcessing(undefined);\n        setTokenCount(0);\n        setStreamingChunks([]);\n        setSpinnerMessage(null);\n    }, []);\n    \n    // Abort execution helper (from chunk_0640.js:95-98)\n    function abortExecution() {\n        if (clearExecutionState(), executionQueue[0]) {\n            executionQueue[0].onAbort();\n            setExecutionQueue([]);\n        } else {\n            abortController?.abort();\n        }\n    }\n    \n    // Execute queued commands (from chunk_0640.js:99-103)\n    const executeQueuedCommands = useCallback(() => {\n        if (queuedCommands.length === 0) return;\n        \n        const commandText = [...queuedCommands.map(cmd => cmd.value), currentInput]\n            .filter(Boolean)\n            .join('\\n');\n        \n        setCurrentInput(commandText);\n        setInputMode('prompt');\n        setQueuedCommands([]);\n    }, [queuedCommands, currentInput]);\n    \n    // Main conversation execution (from chunk_0640.js:169-234)\n    const executeConversation = useCallback(async () => {\n        try {\n            // Verify authentication\n            await verifyAuthentication();\n            \n            // Load file state\n            const fileContext = loadFileContext();\n            updateFileContext(fileContext);\n            \n            if (!initialPrompt) return;\n            \n            // Set processing state\n            setIsProcessing(true);\n            setTokenCount(0);\n            setStreamingChunks([]);\n            \n            // Initialize checkpointing\n            const checkpointingContext = await initializeCheckpointing(\n                initialPrompt,\n                'prompt',\n                appState.checkpointing,\n                (newState) => {\n                    setAppState(prevState => ({\n                        ...prevState,\n                        checkpointing: newState\n                    }));\n                }\n            );\n            \n            // Create abort controller\n            const controller = createAbortController();\n            setAbortController(controller);\n            \n            // Process initial input\n            const {\n                messages: newMessages,\n                shouldQuery,\n                allowedTools\n            } = await processUserInput({\n                input: initialPrompt,\n                mode: 'prompt',\n                setIsLoading: setIsProcessing,\n                setToolJSX,\n                context: createExecutionContext(messages, [], controller, [], undefined),\n                ideSelection: selectedIDE,\n                autocheckpoint: checkpointingContext,\n                messages: messages,\n                setUserInputOnProcessing\n            });\n            \n            if (newMessages.length) {\n                // Track user input\n                for (const message of newMessages) {\n                    if (message.type === 'user') {\n                        trackUserInput(initialPrompt);\n                    }\n                }\n                \n                // Update messages\n                setMessages(prevMessages => [...prevMessages, ...newMessages]);\n                \n                if (!shouldQuery) {\n                    clearExecutionState();\n                    setAbortController(null);\n                    return;\n                }\n                \n                // Execute conversation with AI\n                await executeAIConversation({\n                    messages: [...messages, ...newMessages],\n                    newMessages,\n                    controller,\n                    allowedTools,\n                    checkpointingContext\n                });\n            } else {\n                trackUserInput(initialPrompt);\n            }\n            \n            // Update acknowledgment state\n            updateCostAcknowledgment();\n            clearExecutionState();\n            \n        } catch (error) {\n            handleConversationError(error);\n            clearExecutionState();\n        }\n    }, [initialPrompt, messages, selectedIDE, appState]);\n    \n    // AI conversation execution (from chunk_0640.js:235-300+)\n    const executeAIConversation = useCallback(async ({\n        messages: conversationMessages,\n        newMessages,\n        controller,\n        allowedTools,\n        checkpointingContext\n    }) => {\n        try {\n            const isFirstMessage = !conversationMessages.find(msg => msg.type === 'user');\n            \n            // Update messages state\n            setMessages(prevMessages => [...prevMessages, ...newMessages]);\n            setTokenCount(0);\n            setStreamingChunks([]);\n            \n            const lastMessage = newMessages.filter(msg => msg.type === 'user' || msg.type === 'assistant').pop();\n            \n            // Handle query start\n            if (shouldHandleQuery(conversationMessages)) {\n                handleQueryStart(mergedMcpClientsComputed);\n                const clientToConnect = findClientToConnect(mergedMcpClientsComputed);\n                if (clientToConnect) {\n                    await connectMcpClient(clientToConnect);\n                }\n            }\n            \n            // Process user message content\n            if (lastMessage?.type === 'user' && typeof lastMessage.message.content === 'string') {\n                await processUserMessageContent(lastMessage.message.content);\n            }\n            \n            // Update spinner state for first message\n            if (!isFirstMessage) {\n                setAppState(prevState => ({\n                    ...prevState,\n                    spinnerTip: undefined\n                }));\n                \n                // Get spinner configuration\n                const spinnerConfig = await getSpinnerConfiguration();\n                updateSpinnerConfiguration(spinnerConfig);\n            }\n            \n            // Prepare execution context\n            const executionContext = createExecutionContext(\n                conversationMessages,\n                newMessages,\n                controller,\n                allowedTools || [],\n                appState.mainLoopModel\n            );\n            \n            // Get system prompts and context\n            const [systemPrompts, userContext, systemContext] = await Promise.all([\n                buildSystemPrompts(availableToolsComputed, appState.mainLoopModel, appState.toolPermissionContext.additionalWorkingDirectories, mergedMcpClientsComputed, appState.toolPermissionContext),\n                getUserContext(),\n                getSystemContext()\n            ]);\n            \n            const finalSystemPrompts = [...systemPrompts, ...(appendSystemPrompt ? [appendSystemPrompt] : [])];\n            \n            // Create enhanced context for tools\n            const enhancedContext = allowedTools ? {\n                ...executionContext,\n                getToolPermissionContext() {\n                    const baseContext = createInitialPermissionContext();\n                    return {\n                        ...baseContext,\n                        alwaysAllowRules: {\n                            ...baseContext.alwaysAllowRules,\n                            command: allowedTools\n                        }\n                    };\n                }\n            } : executionContext;\n            \n            // Determine prompt category\n            const promptCategory = determinePromptCategory();\n            \n            // Execute streaming conversation\n            for await (const chunk of streamConversation({\n                messages: conversationMessages,\n                systemPrompt: finalSystemPrompts,\n                userContext,\n                systemContext,\n                canUseTool: createToolFilter(executionQueue),\n                toolUseContext: enhancedContext,\n                promptCategory\n            })) {\n                await processConversationChunk(\n                    chunk,\n                    (message) => {\n                        setMessages(prevMessages => [...prevMessages, message]);\n                    },\n                    (textChunk) => setTokenCount(prevCount => prevCount + textChunk.length),\n                    setStreamMode,\n                    setStreamingChunks\n                );\n            }\n            \n        } catch (error) {\n            handleConversationError(error);\n            throw error;\n        }\n    }, [mergedMcpClientsComputed, availableToolsComputed, appendSystemPrompt, appState, executionQueue]);\n    \n    // Create execution context (from chunk_0640.js:117-168)\n    const createExecutionContext = useCallback((messages, newMessages, abortController, allowedCommands, model) => {\n        return {\n            abortController,\n            options: {\n                commands: mergedCommands,\n                tools: availableToolsComputed,\n                debug,\n                verbose: appState.verbose,\n                mainLoopModel: model,\n                maxThinkingTokens: calculateMaxThinkingTokens(newMessages, model),\n                mcpClients: mergedMcpClientsComputed,\n                mcpResources: appState.mcp.resources,\n                ideInstallationStatus,\n                isNonInteractiveSession: false,\n                dynamicMcpConfig: mcpConfigOverride,\n                theme: getCurrentTheme()\n            },\n            getToolPermissionContext() {\n                if (!allowedCommands.length) {\n                    return createInitialPermissionContext();\n                }\n                return {\n                    ...createInitialPermissionContext(),\n                    alwaysAllowRules: {\n                        ...createInitialPermissionContext().alwaysAllowRules,\n                        command: allowedCommands\n                    }\n                };\n            },\n            getQueuedCommands() {\n                return queuedCommandsRef.current;\n            },\n            removeQueuedCommands(commandsToRemove) {\n                setQueuedCommands(prevCommands => \n                    prevCommands.filter(cmd => !commandsToRemove.includes(cmd))\n                );\n            },\n            messages,\n            setMessages,\n            setMessageHistory,\n            onChangeAPIKey: handleAPIKeyChange,\n            readFileState: getFileState(),\n            setToolJSX,\n            addNotification: setNotification,\n            setToolPermissionContext: (newContext) => {\n                setAppState(prevState => ({\n                    ...prevState,\n                    toolPermissionContext: newContext\n                }));\n            },\n            onChangeDynamicMcpConfig: setMcpConfigOverride,\n            onInstallIDEExtension: setIDEToInstallExtension,\n            nestedMemoryAttachmentTriggers: new Set(),\n            setResponseLength,\n            setStreamMode,\n            setSpinnerMessage,\n            setInProgressToolUseIDs,\n            agentId: agentManager.getCurrentAgentId(),\n            resume: handleConversationResume\n        };\n    }, [mergedCommands, availableToolsComputed, debug, appState, mergedMcpClientsComputed, ideInstallationStatus, mcpConfigOverride, queuedCommandsRef]);\n    \n    // Handle conversation resume (from chunk_0640.js:77-81)\n    const handleConversationResume = useCallback(async (agentId, conversationData) => {\n        const resumeMessages = transformMessagesForResume(conversationData.messages, availableToolsComputed);\n        const resumeCommands = await loadResumeCommands('resume');\n        \n        resumeMessages.push(...resumeCommands);\n        \n        persistConversationData(conversationData);\n        clearExecutionState();\n        setAbortController(null);\n        \n        await refreshSystemState();\n        updateAgentId(agentId);\n        setMessages(() => resumeMessages);\n        setToolJSX(null);\n        setCurrentInput('');\n        setMessageHistory([]);\n    }, [availableToolsComputed, clearExecutionState]);\n    \n    // Initialize conversation on mount\n    useEffect(() => {\n        if (initialPrompt) {\n            executeConversation();\n        }\n    }, []);\n    \n    // Render the interactive interface\n    return (\n        <React.Fragment>\n            <AppStateProvider\n                initialState={appState}\n                onChangeAppState={setAppState}\n            >\n                <InteractiveInterface\n                    debug={debug}\n                    initialPrompt={initialPrompt}\n                    commands={mergedCommands}\n                    initialTools={availableToolsComputed}\n                    initialMessages={messages}\n                    initialTodos={initialTodos}\n                    initialCheckpoints={appState.checkpointing.checkpoints}\n                    mcpClients={mergedMcpClientsComputed}\n                    dynamicMcpConfig={mcpConfigOverride}\n                    autoConnectIdeFlag={autoConnectIdeFlag}\n                    strictMcpConfig={strictMcpConfig}\n                    appendSystemPrompt={appendSystemPrompt}\n                    \n                    // Event handlers\n                    onExecuteConversation={executeConversation}\n                    onAbortExecution={abortExecution}\n                    onExecuteQueuedCommands={executeQueuedCommands}\n                    onConversationResume={handleConversationResume}\n                    \n                    // State\n                    currentMode={currentMode}\n                    isProcessing={isProcessing}\n                    isStreaming={isStreaming}\n                    currentInput={currentInput}\n                    streamingChunks={streamingChunks}\n                    notification={notification}\n                    toolJSX={toolJSX}\n                    queuedCommands={queuedCommands}\n                    \n                    // State setters\n                    setCurrentMode={setCurrentMode}\n                    setCurrentInput={setCurrentInput}\n                    setIsProcessing={setIsProcessing}\n                    setQueuedCommands={setQueuedCommands}\n                    setNotification={setNotification}\n                />\n            </AppStateProvider>\n        </React.Fragment>\n    );\n}\n\n/**\n * Start interactive application\n */\nexport class InteractiveAppManager {\n    constructor(config) {\n        this.config = config;\n        this.isRunning = false;\n    }\n    \n    async start() {\n        if (this.isRunning) {\n            throw new Error('Interactive app is already running');\n        }\n        \n        this.isRunning = true;\n        \n        try {\n            console.log('🚀 Starting Claude Code interactive session');\n            \n            // Render the React application\n            const { rerender, unmount } = render(\n                <InteractiveApp {...this.config} />\n            );\n            \n            this.rerender = rerender;\n            this.unmount = unmount;\n            \n            // Set up cleanup handlers\n            process.on('SIGINT', this.handleExit.bind(this));\n            process.on('SIGTERM', this.handleExit.bind(this));\n            \n        } catch (error) {\n            this.isRunning = false;\n            throw new Error(`Failed to start interactive app: ${error.message}`);\n        }\n    }\n    \n    async stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        \n        console.log('🛑 Stopping Claude Code interactive session');\n        \n        this.isRunning = false;\n        \n        if (this.unmount) {\n            this.unmount();\n        }\n        \n        // Clean up resources\n        await this.cleanup();\n    }\n    \n    async handleExit(signal) {\n        console.log(`\\n📞 Received ${signal}, gracefully shutting down...`);\n        await this.stop();\n        process.exit(0);\n    }\n    \n    async cleanup() {\n        // Clean up MCP connections\n        await mcpServerManager.stopServers();\n        \n        // Clean up hooks\n        await hookManager.cleanup();\n        \n        // Clean up agents\n        await agentManager.cleanup();\n        \n        console.log('✅ Interactive session cleanup completed');\n    }\n}\n\n// Helper functions (placeholders for missing implementations)\nfunction getMainLoopModel() { return null; }\nfunction createInitialPermissionContext() { return {}; }\nfunction mergeMcpClients() { return []; }\nfunction createToolSystem() { return []; }\nfunction initializeInteractiveSystem() { /* Implementation needed */ }\nfunction initializeIDEIntegration() { /* Implementation needed */ }\nfunction cleanup() { /* Implementation needed */ }\nfunction manageMcpClients() { /* Implementation needed */ }\nfunction integrateWithMcpClients() { /* Implementation needed */ }\nfunction verifyAuthentication() { /* Implementation needed */ }\nfunction loadFileContext() { return []; }\nfunction updateFileContext() { /* Implementation needed */ }\nfunction initializeCheckpointing() { /* Implementation needed */ }\nfunction createAbortController() { return new AbortController(); }\nfunction processUserInput() { /* Implementation needed */ }\nfunction trackUserInput() { /* Implementation needed */ }\nfunction executeAIConversation() { /* Implementation needed */ }\nfunction updateCostAcknowledgment() { /* Implementation needed */ }\nfunction handleConversationError() { /* Implementation needed */ }\nfunction shouldHandleQuery() { return false; }\nfunction handleQueryStart() { /* Implementation needed */ }\nfunction findClientToConnect() { return null; }\nfunction connectMcpClient() { /* Implementation needed */ }\nfunction processUserMessageContent() { /* Implementation needed */ }\nfunction getSpinnerConfiguration() { return {}; }\nfunction updateSpinnerConfiguration() { /* Implementation needed */ }\nfunction buildSystemPrompts() { return []; }\nfunction getUserContext() { return {}; }\nfunction getSystemContext() { return {}; }\nfunction determinePromptCategory() { return 'default'; }\nfunction streamConversation() { return []; }\nfunction createToolFilter() { return () => true; }\nfunction processConversationChunk() { /* Implementation needed */ }\nfunction calculateMaxThinkingTokens() { return 0; }\nfunction getCurrentTheme() { return {}; }\nfunction handleAPIKeyChange() { /* Implementation needed */ }\nfunction getFileState() { return new Map(); }\nfunction transformMessagesForResume() { return []; }\nfunction loadResumeCommands() { return []; }\nfunction persistConversationData() { /* Implementation needed */ }\nfunction refreshSystemState() { /* Implementation needed */ }\nfunction updateAgentId() { /* Implementation needed */ }\n\n// Placeholder React components\nfunction AppStateProvider({ children, initialState, onChangeAppState }) {\n    return children;\n}\n\nfunction InteractiveInterface(props) {\n    return React.createElement('div', null, 'Claude Code Interactive Interface (placeholder)');\n}