/* chunk:351 bytes:[8295237, 8310086) size:14849 source:unpacked-cli.js */
var EV0 = E((C8) => {
    Object.defineProperty(C8, "__esModule", {
        value: !0
    });
    C8.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX = C8.createCertificateProviderChannelCredentials = C8.FileWatcherCertificateProvider = C8.createCertificateProviderServerCredentials = C8.createServerCredentialsWithInterceptors = C8.BaseSubchannelWrapper = C8.registerAdminService = C8.FilterStackFactory = C8.BaseFilter = C8.PickResultType = C8.QueuePicker = C8.UnavailablePicker = C8.ChildLoadBalancerHandler = C8.EndpointMap = C8.endpointHasAddress = C8.endpointToString = C8.subchannelAddressToString = C8.LeafLoadBalancer = C8.isLoadBalancerNameRegistered = C8.parseLoadBalancingConfig = C8.selectLbConfigFromList = C8.registerLoadBalancerType = C8.createChildChannelControlHelper = C8.BackoffTimeout = C8.parseDuration = C8.durationToMs = C8.splitHostPort = C8.uriToString = C8.createResolver = C8.registerResolver = C8.log = C8.trace = void 0;
    var z0B = I7();
    Object.defineProperty(C8, "trace", {
        enumerable: !0,
        get: function() {
            return z0B.trace
        }
    });
    Object.defineProperty(C8, "log", {
        enumerable: !0,
        get: function() {
            return z0B.log
        }
    });
    var E0B = DM();
    Object.defineProperty(C8, "registerResolver", {
        enumerable: !0,
        get: function() {
            return E0B.registerResolver
        }
    });
    Object.defineProperty(C8, "createResolver", {
        enumerable: !0,
        get: function() {
            return E0B.createResolver
        }
    });
    var U0B = mV();
    Object.defineProperty(C8, "uriToString", {
        enumerable: !0,
        get: function() {
            return U0B.uriToString
        }
    });
    Object.defineProperty(C8, "splitHostPort", {
        enumerable: !0,
        get: function() {
            return U0B.splitHostPort
        }
    });
    var w0B = CV0();
    Object.defineProperty(C8, "durationToMs", {
        enumerable: !0,
        get: function() {
            return w0B.durationToMs
        }
    });
    Object.defineProperty(C8, "parseDuration", {
        enumerable: !0,
        get: function() {
            return w0B.parseDuration
        }
    });
    var R$6 = t31();
    Object.defineProperty(C8, "BackoffTimeout", {
        enumerable: !0,
        get: function() {
            return R$6.BackoffTimeout
        }
    });
    var P71 = Wm();
    Object.defineProperty(C8, "createChildChannelControlHelper", {
        enumerable: !0,
        get: function() {
            return P71.createChildChannelControlHelper
        }
    });
    Object.defineProperty(C8, "registerLoadBalancerType", {
        enumerable: !0,
        get: function() {
            return P71.registerLoadBalancerType
        }
    });
    Object.defineProperty(C8, "selectLbConfigFromList", {
        enumerable: !0,
        get: function() {
            return P71.selectLbConfigFromList
        }
    });
    Object.defineProperty(C8, "parseLoadBalancingConfig", {
        enumerable: !0,
        get: function() {
            return P71.parseLoadBalancingConfig
        }
    });
    Object.defineProperty(C8, "isLoadBalancerNameRegistered", {
        enumerable: !0,
        get: function() {
            return P71.isLoadBalancerNameRegistered
        }
    });
    var O$6 = wS1();
    Object.defineProperty(C8, "LeafLoadBalancer", {
        enumerable: !0,
        get: function() {
            return O$6.LeafLoadBalancer
        }
    });
    var qS1 = OE();
    Object.defineProperty(C8, "subchannelAddressToString", {
        enumerable: !0,
        get: function() {
            return qS1.subchannelAddressToString
        }
    });
    Object.defineProperty(C8, "endpointToString", {
        enumerable: !0,
        get: function() {
            return qS1.endpointToString
        }
    });
    Object.defineProperty(C8, "endpointHasAddress", {
        enumerable: !0,
        get: function() {
            return qS1.endpointHasAddress
        }
    });
    Object.defineProperty(C8, "EndpointMap", {
        enumerable: !0,
        get: function() {
            return qS1.EndpointMap
        }
    });
    var T$6 = NP1();
    Object.defineProperty(C8, "ChildLoadBalancerHandler", {
        enumerable: !0,
        get: function() {
            return T$6.ChildLoadBalancerHandler
        }
    });
    var zV0 = Wx();
    Object.defineProperty(C8, "UnavailablePicker", {
        enumerable: !0,
        get: function() {
            return zV0.UnavailablePicker
        }
    });
    Object.defineProperty(C8, "QueuePicker", {
        enumerable: !0,
        get: function() {
            return zV0.QueuePicker
        }
    });
    Object.defineProperty(C8, "PickResultType", {
        enumerable: !0,
        get: function() {
            return zV0.PickResultType
        }
    });
    var P$6 = cX0();
    Object.defineProperty(C8, "BaseFilter", {
        enumerable: !0,
        get: function() {
            return P$6.BaseFilter
        }
    });
    var S$6 = mX0();
    Object.defineProperty(C8, "FilterStackFactory", {
        enumerable: !0,
        get: function() {
            return S$6.FilterStackFactory
        }
    });
    var j$6 = MP1();
    Object.defineProperty(C8, "registerAdminService", {
        enumerable: !0,
        get: function() {
            return j$6.registerAdminService
        }
    });
    var k$6 = XS1();
    Object.defineProperty(C8, "BaseSubchannelWrapper", {
        enumerable: !0,
        get: function() {
            return k$6.BaseSubchannelWrapper
        }
    });
    var $0B = HS1();
    Object.defineProperty(C8, "createServerCredentialsWithInterceptors", {
        enumerable: !0,
        get: function() {
            return $0B.createServerCredentialsWithInterceptors
        }
    });
    Object.defineProperty(C8, "createCertificateProviderServerCredentials", {
        enumerable: !0,
        get: function() {
            return $0B.createCertificateProviderServerCredentials
        }
    });
    var y$6 = H0B();
    Object.defineProperty(C8, "FileWatcherCertificateProvider", {
        enumerable: !0,
        get: function() {
            return y$6.FileWatcherCertificateProvider
        }
    });
    var _$6 = r31();
    Object.defineProperty(C8, "createCertificateProviderChannelCredentials", {
        enumerable: !0,
        get: function() {
            return _$6.createCertificateProviderChannelCredentials
        }
    });
    var x$6 = rX0();
    Object.defineProperty(C8, "SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX", {
        enumerable: !0,
        get: function() {
            return x$6.SUBCHANNEL_ARGS_EXCLUDE_KEY_PREFIX
        }
    })
});
var L0B = E((N0B) => {
    Object.defineProperty(N0B, "__esModule", {
        value: !0
    });
    N0B.setup = f$6;
    var b$6 = DM();
    class q0B {
        constructor(A, B, Q) {
            this.listener = B, this.hasReturnedResult = !1, this.endpoints = [];
            let Z;
            if (A.authority === "") Z = "/" + A.path;
            else Z = A.path;
            this.endpoints = [{
                addresses: [{
                    path: Z
                }]
            }]
        }
        updateResolution() {
            if (!this.hasReturnedResult) this.hasReturnedResult = !0, process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {})
        }
        destroy() {
            this.hasReturnedResult = !1
        }
        static getDefaultAuthority(A) {
            return "localhost"
        }
    }

    function f$6() {
        b$6.registerResolver("unix", q0B)
    }
});
var S0B = E((P0B) => {
    Object.defineProperty(P0B, "__esModule", {
        value: !0
    });
    P0B.setup = d$6;
    var M0B = W1("net"),
        NS1 = b6(),
        UV0 = IJ(),
        R0B = DM(),
        O0B = mV(),
        g$6 = I7(),
        u$6 = "ip_resolver";

    function T0B(A) {
        g$6.trace(NS1.LogVerbosity.DEBUG, u$6, A)
    }
    var wV0 = "ipv4",
        $V0 = "ipv6",
        m$6 = 443;
    class qV0 {
        constructor(A, B, Q) {
            var Z;
            this.listener = B, this.endpoints = [], this.error = null, this.hasReturnedResult = !1, T0B("Resolver constructed for target " + O0B.uriToString(A));
            let D = [];
            if (!(A.scheme === wV0 || A.scheme === $V0)) {
                this.error = {
                    code: NS1.Status.UNAVAILABLE,
                    details: `Unrecognized scheme ${A.scheme} in IP resolver`,
                    metadata: new UV0.Metadata
                };
                return
            }
            let G = A.path.split(",");
            for (let F of G) {
                let I = O0B.splitHostPort(F);
                if (I === null) {
                    this.error = {
                        code: NS1.Status.UNAVAILABLE,
                        details: `Failed to parse ${A.scheme} address ${F}`,
                        metadata: new UV0.Metadata
                    };
                    return
                }
                if (A.scheme === wV0 && !M0B.isIPv4(I.host) || A.scheme === $V0 && !M0B.isIPv6(I.host)) {
                    this.error = {
                        code: NS1.Status.UNAVAILABLE,
                        details: `Failed to parse ${A.scheme} address ${F}`,
                        metadata: new UV0.Metadata
                    };
                    return
                }
                D.push({
                    host: I.host,
                    port: (Z = I.port) !== null && Z !== void 0 ? Z : m$6
                })
            }
            this.endpoints = D.map((F) => ({
                addresses: [F]
            })), T0B("Parsed " + A.scheme + " address list " + D)
        }
        updateResolution() {
            if (!this.hasReturnedResult) this.hasReturnedResult = !0, process.nextTick(() => {
                if (this.error) this.listener.onError(this.error);
                else this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {})
            })
        }
        destroy() {
            this.hasReturnedResult = !1
        }
        static getDefaultAuthority(A) {
            return A.path.split(",")[0]
        }
    }

    function d$6() {
        R0B.registerResolver(wV0, qV0), R0B.registerResolver($V0, qV0)
    }
});
var b0B = E((x0B) => {
    Object.defineProperty(x0B, "__esModule", {
        value: !0
    });
    x0B.RoundRobinLoadBalancer = void 0;
    x0B.setup = a$6;
    var y0B = Wm(),
        FX = RE(),
        NV0 = Wx(),
        l$6 = I7(),
        p$6 = b6(),
        j0B = OE(),
        i$6 = wS1(),
        n$6 = "round_robin";

    function k0B(A) {
        l$6.trace(p$6.LogVerbosity.DEBUG, n$6, A)
    }
    var LS1 = "round_robin";
    class LV0 {
        getLoadBalancerName() {
            return LS1
        }
        constructor() {}
        toJsonObject() {
            return {
                [LS1]: {}
            }
        }
        static createFromJson(A) {
            return new LV0
        }
    }
    class _0B {
        constructor(A, B = 0) {
            this.children = A, this.nextIndex = B
        }
        pick(A) {
            let B = this.children[this.nextIndex].picker;
            return this.nextIndex = (this.nextIndex + 1) % this.children.length, B.pick(A)
        }
        peekNextEndpoint() {
            return this.children[this.nextIndex].endpoint
        }
    }
    class MV0 {
        constructor(A) {
            this.channelControlHelper = A, this.children = [], this.currentState = FX.ConnectivityState.IDLE, this.currentReadyPicker = null, this.updatesPaused = !1, this.lastError = null, this.childChannelControlHelper = y0B.createChildChannelControlHelper(A, {
                updateState: (B, Q, Z) => {
                    if (this.currentState === FX.ConnectivityState.READY && B !== FX.ConnectivityState.READY) this.channelControlHelper.requestReresolution();
                    if (Z) this.lastError = Z;
                    this.calculateAndUpdateState()
                }
            })
        }
        countChildrenWithState(A) {
            return this.children.filter((B) => B.getConnectivityState() === A).length
        }
        calculateAndUpdateState() {
            if (this.updatesPaused) return;
            if (this.countChildrenWithState(FX.ConnectivityState.READY) > 0) {
                let A = this.children.filter((Q) => Q.getConnectivityState() === FX.ConnectivityState.READY),
                    B = 0;
                if (this.currentReadyPicker !== null) {
                    let Q = this.currentReadyPicker.peekNextEndpoint();
                    if (B = A.findIndex((Z) => j0B.endpointEqual(Z.getEndpoint(), Q)), B < 0) B = 0
                }
                this.updateState(FX.ConnectivityState.READY, new _0B(A.map((Q) => ({
                    endpoint: Q.getEndpoint(),
                    picker: Q.getPicker()
                })), B), null)
            } else if (this.countChildrenWithState(FX.ConnectivityState.CONNECTING) > 0) this.updateState(FX.ConnectivityState.CONNECTING, new NV0.QueuePicker(this), null);
            else if (this.countChildrenWithState(FX.ConnectivityState.TRANSIENT_FAILURE) > 0) {
                let A = `round_robin: No connection established. Last error: ${this.lastError}`;
                this.updateState(FX.ConnectivityState.TRANSIENT_FAILURE, new NV0.UnavailablePicker({
                    details: A
                }), A)
            } else this.updateState(FX.ConnectivityState.IDLE, new NV0.QueuePicker(this), null);
            for (let A of this.children)
                if (A.getConnectivityState() === FX.ConnectivityState.IDLE) A.exitIdle()
        }
        updateState(A, B, Q) {
            if (k0B(FX.ConnectivityState[this.currentState] + " -> " + FX.ConnectivityState[A]), A === FX.ConnectivityState.READY) this.currentReadyPicker = B;
            else this.currentReadyPicker = null;
            this.currentState = A, this.channelControlHelper.updateState(A, B, Q)
        }
        resetSubchannelList() {
            for (let A of this.children) A.destroy()
        }
        updateAddressList(A, B, Q) {
            this.resetSubchannelList(), k0B("Connect to endpoint list " + A.map(j0B.endpointToString)), this.updatesPaused = !0, this.children = A.map((Z) => new i$6.LeafLoadBalancer(Z, this.childChannelControlHelper, Q));
            for (let Z of this.children) Z.startConnecting();
            this.updatesPaused = !1, this.calculateAndUpdateState()
        }
        exitIdle() {}
        resetBackoff() {}
        destroy() {
            this.resetSubchannelList()
        }
        getTypeName() {
            return LS1
        }
    }
    x0B.RoundRobinLoadBalancer = MV0;

    function a$6() {
        y0B.registerLoadBalancerType(LS1, MV0, LV0)
    }
});